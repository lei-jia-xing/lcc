# LCC 编译器 - 总结感想

编译原理终于到了尾声，我制作的 LCC 编译器也告一段落。从最初的词法分析器（Lexer），语法分析器（Parser），再到语义分析器（Semantic Analyzer）
，中端代码生成 (CodeGen)，后端代码生成 (Backend)，一步步实现了一个完整的编译器流水线。整个过程还是非常煎熬的，但也让我学到了很多。

其实我开始是想做 LLVM IR 的，但是最后还是做了自制四元式，主要是想要体验一下自己设计四元式🫠，今后如果真的做编译器相关工作，那也是调llvm的api,
站在巨人的肩膀上😗。

稍微说一下心路历程吧，其实做到Parser时，明显就感觉代码量上来了，到语义分析阶段对整个架构其实还是比较模糊的，我得出的符号表也是根本没有用，
这也是做到后面才感觉到前面做的工作不够，这其实也增进了编译器每一个模块到底要什么的理解，中途也重构过非常多次，在这个过程也玩了一下C++你不
得不品的智能指针，其实挺好用的。做的最痛苦的地方就在于编译器优化了，因为我的自定义四元式设计的不是很好，一个ir指令做了太多的事情，ir过于高级,
而llvm ir则不然，每一个指令有什么副作用，是use还是def,都非常清晰，这导致我很多地方都需要特殊判断，这严重影响了我的优化设计，debug 过程相当痛苦。
不过这也提醒我，编译器架构设计非常的重要，和可维护性息息相关。

做到后端代码生成是，痛苦初现端倪，因为我设计的ir过于高级，我需要做大量的if else来处理各种特殊情况，导致代码量暴增，调试也非常困难,不过最后
还是捏着鼻子做完了，一个可拓展性极差的ir

整个优化过程最为痛苦的就是代码优化，前面提到我糟糕的ir设计诞生出了一大堆if else的🚽，中间过程还遇到了一些由于我的ir输出顺序和过于高级的语义
不得不反复修改，比如`PARAM`这一个运算符，原来他负责声明并且直接存放到函数栈帧中，然后在后端函数直接预处理，这造成了我`PARAM`无法加入到图着色算法
优化效果会少很多，后面细分了他的作用，增加了一个值传递的临时变量，这样就可以根据`ALLOCA`指令进行Mem2Reg优化了，这也充分体现出编译器IR 设计的
必要性

代码优化中，最为痛苦的是mem2reg,排查了相当长的时间，需要和CFG和DOM配合使用，才能正确的进行变量提升，其实关键就在于变量提升，我们必须识别出
那些变量可以被提升，哪些因为副作用不能提升,在这个过程中遇到了de了很多天的bug,因为mem2reg是后续优化的基础，必须正确，而且涉及的编译器组件非常
广泛,中端，后端，CFG,Dom和Mem2Reg都要关注，这也是编译器优化的试金石。

完成了这个玩具编译器，看到那些我平时写出来的程序正在被我自己写的编译器编译成汇编，最后输出正确的结果，总体来说还是非常有成就感的，最后总体
看看我的工作，统计了一下代码行数（包括注释和空行及其文档）,足足有13000多行，如果是纯代码的话也有8500行，完成这种规模的C++小项目也是变成高手
的第一步吧
