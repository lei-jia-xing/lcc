# LCC 编译器优化系统设计

## 1. 优化系统架构

### 1.1 总体架构

LCC 的优化系统采用经典的 SSA-based 优化架构，整个优化管线分为三个核心阶段：

- **SSA 构建阶段**：将传统中间表示转换为静态单赋值形式
- **优化执行阶段**：在 SSA 形式上执行多种优化变换
- **SSA 销毁阶段**：将优化后的 SSA 代码转换为可执行的目标代码

### 1.2 优化管线流程

优化管线按照以下顺序执行各优化 Pass：

1. 支配树构建
2. 内存到寄存器转换
3. 迭代优化循环
4. Phi 指令消除

## 2. 支配分析

### 2.1 支配关系定义

支配分析是构建 SSA 形式和实现多种优化的基础。给定控制流图 CFG 中的基本块 B1 和 B2，称 B1 支配 B2 当且仅当从入口块到 B2 的每条路径都必须经过 B1。每个基本块存在唯一的直接支配前驱，所有支配关系构成一棵支配树。

### 2.2 支配树算法

LCC 采用迭代算法计算支配集。算法基于数据流方程：

- 对于入口块：$Dom(entry) = {entry}$
- 对于非入口块 $b：Dom(b) = {b} ∩_{p∈pred(b)} Dom(p)$

算法通过不断迭代更新支配集直至达到不动点。对于不可达块（无前驱的块），清空其支配集以避免错误分析结果。

## 3. 优化 Pass：支配树构建

### 3.1 实现概述

支配树构建是整个优化管线的第一步，为后续的 SSA 转换和循环分析奠定基础。该 Pass 分析控制流图，计算每个基本块的支配集合，并构建支配树数据结构。

### 3.2 算法细节

支配树构建 Pass 采用迭代数据流分析方法，主要处理以下任务：

- 初始化入口块的支配集，使其仅包含自身
- 为所有非入口块初始化为包含所有基本块的支配集
- 迭代计算每个块的支配集，直至达到不动点
- 处理不可达块的特殊情况

对于不可达块（无任何前驱的块），算法将其支配集清空。这种处理确保后续分析不会错误地假设这些块被支配。

### 3.3 支配信息的应用

构建的支配树信息被以下优化 Pass 使用：

- Mem2Reg：用于支配边界计算和变量重命名遍历
- LICM：用于循环识别和不变代码判断
- 其他需要控制流分析的优化

支配树数据结构提供了快速查询支配关系的接口，包括直接支配前驱查询、支配子树遍历等。

TODO: 添加下一个优化 Pass

## 4. 优化 Pass：内存到寄存器转换

### 4.1 实现概述

内存到寄存器转换是构建 SSA 形式的核心 Pass。该 Pass 将函数内栈分配的标量变量提升为虚拟寄存器，通过插入 Phi 节点并重命名变量定义，将传统中间表示转换为静态单赋值形式。

### 4.2 可提升变量识别

Pass 首先扫描函数内的所有 ALLOCA 指令，识别可提升的变量。识别标准包括：

- 变量类型为标量类型（非数组）
- 变量的所有定义和使用位置可被准确追踪

对于不可提升的变量（如数组类型变量），保留其原始的内存访问形式。同时，Pass 收集每个被提升变量的所有定义位置所在的块。

### 4.3 支配边界计算

支配边界决定 Phi 节点的插入位置。对于基本块 b，其支配边界 DF(b) 包含所有满足以下条件的块 n：

- b 支配 n 的某个前驱 p
- b 不严格支配 n

支配边界计算采用迭代算法，利用已构建的支配树加速计算过程。支配边界信息确保在控制流汇合点处插入必要的 Phi 节点。

### 4.4 Phi 节点插入

对每个需要提升的变量，Pass 执行以下操作：

- 计算所有定义位置所在块的支配边界的并集
- 在支配边界中的每个块插入 Phi 节点
- Phi 节点的结果操作数为新分配的临时寄存器

Phi 节点的参数个数等于所在块的前驱数量，每个参数对应一个前驱路径上的变量值。Phi 节点的作用是在控制流汇合点处合并来自不同路径的变量值。

### 4.5 变量重命名

变量重命名按照支配树的深度优先遍历顺序进行，主要步骤包括：

- 使用栈结构管理每个变量在不同支配路径下的当前版本
- 遇到变量定义时，分配新的临时寄存器并将新版本压入栈
- 遇到变量使用时，将使用替换为栈顶的当前版本
- 递归处理支配的子块
- 完成子块处理后，弹出栈以恢复上一层的版本

重命名过程确保每个变量定义获得唯一的临时寄存器标识，而每个使用点引用正确的变量版本。

### 4.6 内存操作替换

在重命名完成后，Pass 执行以下清理工作：

- 删除所有已提升变量的 ALLOCA 指令
- 删除对这些变量的 LOAD 和 STORE 指令
- 将 Phi 节点的操作数统一转换为临时寄存器形式

对于未提升的变量，保留其原始的内存访问指令。最终，函数内的中间表示完全转换为 SSA 形式，每个变量在其作用域内仅被赋值一次。

### 4.7 优化效果

Mem2Reg Pass 的效果包括：

- 消除大量内存访问指令，减少 load/store 开销
- 简化数据流分析，使定义-使用关系更加明确
- 为后续优化提供更好的分析基础

**应用场景**

包含多个局部变量赋值和简单计算的函数。

**示例**

```c
// 优化前：使用栈变量
int compute(int x) {
    int a = x + 1;
    int b = a * 2;
    return b;
}
```

经过 Mem2Reg 后，局部变量 `a` 和 `b` 被提升到虚拟寄存器，消除了 ALLOCA/LOAD/STORE 指令。

**优化效果**：消除栈内存分配，减少 load/store 指令数量。变量直接使用寄存器存储，后续优化（如常量传播、死代码消除）可以更高效地分析数据流。


## 5. 优化 Pass：全局常量求值

### 5.1 实现概述

全局常量求值 Pass 实现了跨函数的常量折叠功能。该 Pass 识别函数调用中所有参数为常量的情况，在编译期解释执行目标函数，将调用结果替换为常量，从而减少运行时开销。

### 5.2 常量调用模式识别

Pass 扫描函数内的指令流，识别以下模式：

- 连续的 ARG 指令序列，每个 ARG 指令的操作数为常量
- 紧随其后的 CALL 指令，调用的函数可被求值

对于不满足全常量参数条件的调用（如存在变量参数），Pass 不做处理，保持原调用指令不变。遇到非相关指令（非 ARG 或 CALL）时，重置当前的 ARG 序列状态。

### 5.3 解释执行机制

当识别到满足条件的常量调用时，Pass 启动内部解释器执行目标函数。解释器的主要机制包括：

- 维护变量标识符到常量值的映射表
- 模拟指令执行，逐步更新变量值
- 处理控制流，包括跳转和条件分支
- 记录最终的返回值

解释器仅支持部分指令类型，如赋值、算术运算、逻辑运算等。对于无法处理的指令（如函数调用、内存访问等），解释器终止并返回失败状态。

### 5.4 结果缓存策略

为了避免重复求值，Pass 实现了缓存机制：

- 缓存键由函数名和参数列表组成
- 缓存值为该调用组合的求值结果
- 遇到相同的调用时直接返回缓存结果

缓存机制显著提升了效率，特别是在同一个函数被多次常量调用的情况下。

### 5.5 递归深度控制

为了防止无限递归导致的编译器崩溃，Pass 设置了递归深度上限：

- 每次递归调用时递增深度计数器
- 当深度超过阈值时，放弃当前函数的求值
- 阈值的选取平衡了优化效果和编译时间

递归深度控制确保编译器的稳定性，避免 pathological case 下的性能问题。

### 5.6 代码替换

当解释器成功求值并返回常量结果时，Pass 执行以下替换：

- 将 CALL 指令转换为 ASSIGN 指令
- ASSIGN 指令的操作数为求得的常量值
- 将相关的 ARG 指令标记为 NOP
- 置位 changed 标志以触发后续迭代优化

若求值失败（如无法处理的指令或递归深度超限），则保持原 CALL 指令不变。

### 5.7 优化效果

全局常量求值 Pass 的效果主要体现在：

- 将运行时函数调用转换为编译期常量
- 消除了函数调用的调用开销和参数传递开销
- 为后续常量传播 Pass 提供更多常量信息

该优化特别适用于包含大量常量表达式和辅助函数调用的程序。

**应用场景**

调用纯函数且参数为常量的情况。

**示例**

```c
// 辅助函数
int max(int a, int b) {
    return a > b ? a : b;
}

// 优化前
int compute() {
    int x = max(10, 20);
    return x + 5;
}
```

经过全局常量求值后：

```c
// 优化后
int compute() {
    int x = 20;  // max(10, 20) 在编译期被求值为 20
    return x + 5;
}
```

再配合常量传播与折叠：

```c
// 最终优化结果
int compute() {
    return 25;  // 20 + 5 在编译期计算
}
```

**优化效果**：消除了运行时函数调用开销，将 `max(10, 20)` 转换为常量 `20`。结合后续的常量传播，可以进一步简化为 `return 25`。

## 6. 优化 Pass：局部死代码消除

### 6.1 实现概述

局部死代码消除 Pass 删除对程序输出没有影响的指令。该 Pass 在基本块范围内进行，利用 SSA 形式的特性使得死代码分析更加高效和准确。

### 6.2 副作用指令定义

某些指令即使结果未被使用也不能删除，因为它们产生副作用。Pass 定义了具有副作用的指令类型：

- STORE：修改内存状态
- GOTO、IF、LABEL：影响控制流
- CALL：可能产生外部可见效果
- RETURN：影响函数返回值
- PARAM：影响函数参数传递
- ALLOCA、ARG：影响内存布局
- PHI：SSA 特有的汇聚节点

以上指令无论其结果是否被使用都不会被删除。

### 6.3 引用计数分析

Pass 采用引用计数方法识别死代码，主要步骤包括：

- 第一遍遍历：统计每个临时寄存器的使用次数
  - 扫描所有指令的操作数（arg1、arg2）
  - 统计 Phi 节点的所有参数
  - 对于 RETURN、STORE、ALLOCA、PARAM 指令，统计其结果操作数

- 第二遍遍历：删除满足条件的指令
  - 检查指令是否无副作用
  - 检查结果是否为临时寄存器
  - 检查该临时寄存器的使用计数是否为零
  - 同时满足上述条件时删除指令

### 6.4 死代码识别条件

指令被视为死代码当且仅当满足所有以下条件：

- 指令的操作码不属于副作用指令集合
- 指令的结果操作数类型为临时寄存器
- 该临时寄存器的使用计数为零

使用计数为零意味着该指令的结果没有被任何后续指令引用，因此可以安全删除。

### 6.5 迭代删除策略

Pass 在单次遍历中删除所有识别出的死代码。删除操作采用迭代器模式，确保删除后继续正确遍历剩余指令。每次删除都会置位 changed 标志，触发优化管线的后续迭代。

### 6.6 优化效果

局部 DCE Pass 的效果包括：

- 删除优化过程中产生的临时变量
- 清理常量传播、LICM 等优化留下的冗余指令
- 减少指令总数，降低代码大小
- 减轻后续 Pass 的工作负担

该 Pass 通常与其他优化 Pass 配合使用，形成优化循环，逐步清除所有死代码。

**应用场景**

优化过程中产生的中间临时变量未被使用的情况。

**示例**

```c
// 优化前：包含未使用的临时计算
int compute(int x, int y) {
    int temp = x + y;    // temp 计算但未使用
    int result = x * 2;
    return result;
}
```

经过死代码消除后：

```c
// 优化后：删除了未使用的 temp
int compute(int x, int y) {
    int result = x * 2;
    return result;
}
```

**优化效果**：删除了未使用的计算 `temp = x + y`，减少了 1 条加法指令。该优化常与常量传播、代数简化等 Pass 配合，逐步清除冗余代码。


## 7. 优化 Pass：常量传播与折叠

### 7.1 实现概述

常量传播 Pass 将已知的常量值沿数据流传播到使用点，常量折叠 Pass 则用计算结果替换常量表达式。这两个优化紧密配合，能够简化表达式并暴露更多优化机会。

### 7.2 数据流分析框架

Pass 采用向前数据流分析方法在基本块内进行优化：

- 维护一个从临时寄存器到常量值的映射表
- 映射表记录当前基本块内已知的常量赋值关系
- 按指令顺序传播常量值
- 根据指令类型更新映射表

该分析仅限于基本块内部，不进行跨块的常量传播，从而简化了实现并降低了分析复杂度。

### 7.3 常量替换策略

Pass 在遍历指令时执行以下替换操作：

- 对于每个指令的操作数，检查其是否为临时寄存器
- 若是临时寄存器且在映射表中存在对应的常量值，则用常量值替换操作数
- 替换操作直接修改指令的操作数字段，不生成新指令

这种原地替换策略避免了额外的指令生成开销，同时保持了中间表示的简洁性。

### 7.4 常量折叠计算

对于二元运算指令，Pass 执行常量折叠：

- 检查两个操作数是否均为常量
- 若是，则直接计算表达式的值
- 将指令的操作码改为 ASSIGN
- 将第一个操作数改为计算结果的常量值
- 清除第二个操作数

常量折叠适用于算术运算、逻辑运算、关系运算等各类二元操作。折叠后的 ASSIGN 指令会更新映射表，供后续指令使用。

### 7.5 映射表更新规则

映射表的更新遵循以下规则：

- 对于 ASSIGN 指令，若源操作数为常量，将结果临时寄存器及其常量值存入映射表
- 对于常量折叠后的指令，同样将结果存入映射表
- 当遇到无法处理的指令（如 STORE、CALL）时，不更新映射表
- 映射表内的值可能在后续被新值覆盖

映射表的更新确保常量信息能够沿数据流正确传播。

### 7.6 与其他优化的协同

常量传播与多个优化 Pass 存在协同效应：

- 与全局常量求值协同：全局求值产生的常量可被进一步传播
- 与 DCE 协同：常量折叠可能使某些临时变量使用计数降为零
- 与 LICM 协同：常量传播有助于识别循环不变代码
- 迭代优化使这些协同效应被充分利用

### 7.7 优化效果

常量传播与折叠 Pass 的效果包括：

- 简化算术和逻辑表达式
- 减少指令总数（通过常量折叠）
- 为死代码消除创造机会
- 为循环不变代码外提提供更多候选指令

**应用场景**

包含常量赋值和常量表达式的代码。

**示例**

```c
// 优化前
int compute(int x) {
    int a = 5;
    int b = 10;
    int c = a + b;     // 可折叠为 15
    int d = c * 2;     // 可进一步优化
    return d + x;
}
```

经过常量传播与折叠后：

```c
// 优化后
int compute(int x) {
    return 30 + x;     // 5 + 10 = 15, 15 * 2 = 30
}
```

**优化效果**：将 4 条赋值指令简化为 1 条返回指令，减少了 3 条中间指令。常量 `5` 和 `10` 被传播并折叠，最终计算出 `30`。

### 7.8 局限性

当前实现的局限性包括：

- 仅处理基本块内的常量传播，未实现跨块的全局传播
- 不支持条件分支上的常量传播
- 未实现函数间的常量传播

这些局限性可作为未来改进方向。

## 7.9 优化 Pass：代数简化

### 7.9.1 实现概述

代数简化 Pass 利用代数恒等式简化表达式，无需计算即可替换为更简单的形式。该 Pass 能够减少不必要的运算，提升代码效率。

### 7.9.2 优化模式

Pass 识别并简化以下代数模式：

- 加法：`x + 0` → `x`，`0 + x` → `x`
- 减法：`x - 0` → `x`
- 乘法：`x * 0` → `0`，`x * 1` → `x`，`1 * x` → `x`
- 除法：`x / 1` → `x`
- 取模：`x % 1` → `0`

这些简化基于数学上的恒等式，保证语义等价性。

### 7.9.3 优化效果

**应用场景**

包含常量操作的算术表达式。

**示例**

```c
// 优化前
int compute(int x) {
    int a = x + 0;
    int b = a * 1;
    int c = x - 0;
    int d = c * 0;
    return d;
}
```

经过代数简化后：

```c
// 优化后
int compute(int x) {
    return 0;  // x + 0 → x, x * 1 → x, x - 0 → x, x * 0 → 0
}
```

**优化效果**：消除了 4 条冗余的算术指令，直接返回常量 `0`。该 Pass 通常与常量传播、DCE 配合，进一步暴露优化机会。

## 7.10 优化 Pass：复制传播

### 7.10.1 实现概述

复制传播 Pass 消除不必要的复制操作。当临时变量被赋值为另一个变量或临时值时，后续使用该临时变量的地方可以直接使用源操作数，从而减少复制指令。

### 7.10.2 复制链追踪

Pass 维护复制映射表，记录临时变量之间的复制关系。对于复制链 `t1 = t0, t2 = t1, t3 = t2`，Pass 会递归追踪到原始源，将 `t3` 的所有使用替换为 `t0`。

### 7.10.3 优化效果

**应用场景**

包含临时变量复制的代码。

**示例**

```c
int compute(int x, int y) {
    int t1 = x;
    int t2 = t1;
    int t3 = t2;
    return t3 + y;
}
```

经过复制传播后：

```c
// 优化后
int compute(int x, int y) {
    return x + y;
}
```

## 7.11 优化 Pass：公共子表达式消除

### 7.11.1 实现概述

公共子表达式消除（CSE）Pass 删除重复计算相同表达式的指令。当相同的表达式被多次计算且操作数未改变时，后续计算可以复用首次计算的结果。

### 7.11.2 表达式识别

Pass 基于支配树分析，在支配范围内追踪已计算的表达式。对于表达式 `e = op(arg1, arg2)`，Pass 使用哈希表记录 `op(arg1, arg2)` 到结果临时寄存器的映射。遇到相同表达式时，直接复用已有结果。

### 7.11.3 交换律处理

对于满足交换律的操作（如 `+`、`*`、`==`、`&&`），Pass 在哈希时规范化操作数顺序，确保 `a + b` 和 `b + a` 被识别为相同表达式。

### 7.11.4 优化效果

**应用场景**

重复计算相同表达式的代码。

**示例**

```c
// 优化前
int compute(int a, int b, int c) {
    int x = a + b;
    int y = a + b;    // 重复计算
    int z = x + y;
    return z;
}
```

经过 CSE 后：

```c
// 优化后
int compute(int a, int b, int c) {
    int x = a + b;
    int y = x;        // 复用 x 的结果
    int z = x + y;
    return z;
}
```

**优化效果**：消除了 1 条重复的加法指令，将第二次 `a + b` 替换为直接使用 `x`。配合复制传播和 DCE，可以进一步优化为 `return 2 * (a + b)`。

## 8. 优化 Pass：循环不变代码外提

### 8.1 实现概述

循环不变代码外提 Pass 将循环体中不随迭代改变的指令移到循环前，避免每次迭代时重复执行相同的计算。该 Pass 能够显著减少循环内的计算量，提升程序性能。

### 8.2 循环识别机制

Pass 首先需要识别程序中的循环结构。基于支配树信息，Pass 识别自然循环：

- 检测控制流图中的回边（即从后继块跳转回其支配前驱的边）
- 回边的目标块即为循环头
- 从循环头出发，通过反向遍历回边，收集所有可达的块
- 这些块构成循环体

循环识别模块提供循环结构信息，包括循环头、循环体块集合、循环深度等。

### 8.3 前驱块构造策略

为了能够安全地外提代码，需要为每个循环构造一个唯一的前驱块。前驱块的作用是作为所有从循环外部进入循环的控制流必经路径。

前驱块构造算法处理以下情况：

- 如果循环已存在唯一的外部前驱块，且该块仅跳转到循环头，则直接复用该块作为前驱块

- 否则，创建一个新的前驱块：
  - 为新前驱块分配标签并初始化指令
  - 将所有来自循环外部的前驱块的跳转目标修改为新前驱块
  - 新前驱块无条件跳转到循环头
  - 更新循环头的 Phi 节点，将来自外部前驱的入边参数修改为指向前驱块

前驱块构造确保了循环有唯一的进入点，为代码外提提供了安全的插入位置。

### 8.4 循环不变性判断

Pass 需要判断循环体内的每条指令是否为循环不变代码。判断条件包括：

- 指令的所有操作数均为循环不变量：
  - 常量被视为循环不变
  - 在循环外定义的临时寄存器被视为循环不变
  - 在循环内定义但在当前迭代前已知的变量需要递归判断

- 指令不依赖于循环体内的定义：即所有操作数的定义点都在循环外
- 指令不会抛出异常或产生副作用：如 STORE、CALL 等指令不能外提
- 指令的执行结果在所有迭代中都相同

满足上述条件的指令被视为循环不变代码，可以安全地外提到循环前。

### 8.5 代码外提操作

对于识别出的循环不变代码，Pass 执行以下外提操作：

- 将指令从循环体中删除
- 将指令插入到前驱块的末尾（在跳转到循环头的指令之前）
- 保持指令的操作数和结果不变

外提操作遵循控制流不变原则，确保外提后的程序语义与原程序相同。

### 8.6 控制流更新

代码外提后，Pass 更新相关的控制流信息：

- 更新前驱块的指令序列
- 保持前驱块到循环头的跳转关系
- 确保循环头的 Phi 节点仍然正确引用前驱块

Pass 还需要处理特殊情况，如循环嵌套、外提指令与循环体内其他指令的依赖关系等。

### 8.7 优化效果

LICM Pass 的效果主要体现在：

- 减少循环体内的指令数量
- 避免重复计算相同的表达式
- 对于包含数组边界检查、不变函数调用等操作的循环，性能提升尤为明显
- 与常量传播、DCE 等优化协同，进一步暴露优化机会

该优化对于计算密集型循环效果显著，是提升程序性能的重要手段。

**应用场景**

循环体内有不随迭代变化的计算。

**示例**

```c
// 优化前：len 在每次循环迭代中都被计算
int sum_array(int arr[], int n) {
    int len = get_length(arr);  // 假设这个值不变
    int sum = 0;
    for (int i = 0; i < n; i++) {
        int bound = len * 2;     // 每次迭代都计算
        if (arr[i] < bound) {
            sum += arr[i];
        }
    }
    return sum;
}
```

经过循环不变代码外提后：

```c
// 优化后：不变计算移到循环前
int sum_array(int arr[], int n) {
    int len = get_length(arr);
    int sum = 0;
    int bound = len * 2;         // 外提到循环前，只计算一次
    for (int i = 0; i < n; i++) {
        if (arr[i] < bound) {
            sum += arr[i];
        }
    }
    return sum;
}
```

**优化效果**：将 `bound = len * 2` 从循环内移到循环前，从 n 次乘法运算减少到 1 次。对于大规模循环，性能提升显著。


## 9. 优化 Pass：Phi 指令消除

### 9.1 实现概述

Phi 指令消除是 SSA 销毁阶段的唯一 Pass。该 Pass 将 SSA 形式中特有的 Phi 指令转换为普通的复制指令，使中间表示能够被后端代码生成器直接使用。Phi 消除是优化管线中的最后一步，完成后即可进行目标代码生成。

### 9.2 Phi 指令的语义

Phi 指令表示在控制流汇合点处根据来源基本块选择相应的变量值。对于形式为 `result = φ(v1, v2, ..., vn)` 的 Phi 节点，其语义是：

- 若控制流从第 i 个前驱块进入当前块，则 result 的值为 vi
- Phi 节点的参数数量等于所在块的前驱数量
- 每个 Phi 参数对应一个前驱路径上的变量值

Phi 指令是一种编译器内部表示，目标代码中不存在对应的直接实现。

### 9.3 临界边问题

Phi 消除面临的主要挑战是如何处理临界边。临界边定义为：

- 源块有多个后继
- 目标块有多个前驱

对于临界边，直接在源块末尾插入复制指令会影响其他后继块，在目标块开头插入复制指令会破坏来自其他前驱的语义。因此需要特殊处理。

### 9.4 复制需求收集

Pass 首先收集所有 Phi 节点对应的复制需求：

- 遍历每个基本块的所有 Phi 节点
- 对于每个 Phi 节点的每个入边（前驱块 p 到当前块 b）：
  - 记录复制目标：Phi 节点的结果操作数
  - 记录复制源：Phi 节点对应的参数操作数
  - 将该复制需求关联到边 (p, b)

所有复制需求按边组织，形成从边到复制列表的映射。每个复制列表包含该边对应的所有 Phi 复制需求。

### 9.5 临界边分裂算法

对于每条边，Pass 检查其是否为临界边。若是，则执行以下分裂操作：

- 创建一个新的基本块（分裂块）作为源块和目标块之间的中介
- 为分裂块分配标签并初始化指令序列
- 将源块的所有指向目标块的跳转指令修改为指向分裂块
- 在分裂块末尾添加无条件跳转指令，跳转到目标块
- 将属于该边的所有复制操作插入到分裂块中

临界边分裂确保了每条边都有唯一的插入位置，同时不破坏其他边的语义。

### 9.6 非临界边处理

对于非临界边，Pass 根据边的性质选择复制操作的插入位置：

- 若目标块仅有这一个前驱：将所有复制操作插入到目标块开头（在 Phi 节点之前）
- 若源块仅有这一个后继：将所有复制操作插入到源块末尾（在跳转指令之前）

这种策略最大限度地减少了对控制流图的修改，同时确保了复制的正确执行。

### 9.7 并行复制解决

对于插入到同一位置的多个复制操作，可能存在依赖关系。例如，复制序列 `a ← b, b ← c, c ← a` 存在循环依赖。Pass 采取以下策略解决并行复制问题：

- 对于没有依赖关系的复制，顺序执行即可
- 对于存在依赖关系的复制，通过引入临时变量打破依赖循环
- 具体实现可采用拓扑排序或临时变量引入等方法

并行复制解决确保了复制操作的正确执行，不会因为依赖关系导致错误的值覆盖。

### 9.8 Phi 节点清除

所有 Phi 节点处理完成后，Pass 执行清理工作：

- 将所有 Phi 节点的操作码改为 NOP
- 清除 Phi 节点的所有操作数
- NOP 指令会被后续的死代码消除 Pass 清理

### 9.9 控制流图更新

Phi 消除过程会修改控制流图结构（插入新的分裂块），因此需要更新基本块之间的前驱和后继关系：

- 更新源块的后继列表，将目标块替换为分裂块
- 更新目标块的前驱列表，将源块替换为分裂块
- 建立分裂块的前驱和后继关系
- 更新支配树等辅助数据结构

控制流图更新确保后续分析能够使用准确的 CFG 信息。

### 9.10 优化效果

Phi 消除是 SSA 销毁的关键步骤，其效果包括：

- 将 SSA 特有的 Phi 指令转换为可执行的复制指令
- 通过临界边分裂确保转换的正确性
- 为后续代码生成提供简洁的中间表示

**应用场景**

包含条件分支和循环的函数，使用 SSA 形式后需要转换回可执行代码。

**示例**

SSA 形式（含 Phi 节点）：

```c
// 伪代码表示 SSA 形式
if (condition) {
    x_1 = 10;
} else {
    x_2 = 20;
}
// 汇聚点需要 Phi 节点
x_3 = φ(x_1, x_2);  // 根据来源选择 x_1 或 x_2
return x_3;
```

经过 Phi 消除后（转换为复制指令）：

```c
if (condition) {
    x = 10;
    goto merge;
} else {
    x = 20;
    goto merge;
}
merge:
// Phi 节点被替换为空或插入复制指令
return x;
```

**优化效果**：将不可直接执行的 Phi 指令转换为标准的赋值和控制流，使代码可以被后端正确生成目标代码。

## 10. 优化管线协调

### 10.1 Pass 间的协同效应

各优化 Pass 之间存在密切的协同关系：

- 常量传播将临时变量替换为常量，可能为 DCE 提供更多优化机会
- DCE 删除冗余指令，可能暴露新的常量传播机会
- LICM 外提的代码可能包含新的常量传播机会
- 全局常量求值生成的常量可以被常量传播进一步传播

迭代策略确保这些协同效应被充分利用。每一轮迭代都会基于上一轮的结果进行优化，逐步逼近局部最优解。

# 11. 做优化中遇到的困难

## 11.1 Mem2Reg Pass 的实现

优化过程中遇到的最大的困难是 Mem2Reg Pass 的实现。这是一个非常重要的优化，有了这个优化，我们不仅可以把 `Variable` 放入到虚拟寄存器中，把局部的变量加入到图着色算法，大幅度减少内存存取，还可以插入 Phi 节点，为后续的优化打下基础。

### 关键难点

**变量提升判断**

- 如何识别可提升的变量：必须是标量类型，不能是数组
- 需要追踪每个变量的所有定义和使用位置
- 判断变量的所有使用是否都能被准确追踪

**支配边界计算**

- 如何正确计算支配边界：支配边界决定了 Phi 节点的插入位置
- 理解支配边界的数学定义：b 的支配边界包含所有满足 "b 支配 n 的某个前驱，但 b 不严格支配 n" 的块 n
- 实现高效的迭代算法来计算支配边界

**Phi 节点插入**

- 在哪些位置插入 Phi 节点：需要在支配边界的块中插入
- Phi 节点需要多少个参数：等于所在块的前驱数量
- 如何正确映射每个参数到对应的前驱块

**变量重命名**

- 按照 CFG 的支配树遍历顺序重命名变量
- 使用栈结构管理每个变量的不同版本
- 正确处理 Phi 节点的参数引用
- 在递归处理子块时正确管理栈的 push/pop

**use/def 分析**

- IR 中每个操作数是 use 还是 def：需要仔细区分
- LOAD 指令：源操作数是 use，结果是 def
- STORE 指令：源操作数和目标操作数都是 use，结果是 def（存储地址）
- Phi 指令：所有参数都是 use，结果是 def

**前后关系处理**

- 如何找到前驱块和后继块：需要正确构建 CFG
- Phi 节点参数与控制流边的对应关系
- 处理不可达块的特殊情况

### 与后端的交互

Mem2Reg 会给后端图着色算法带来压力：

- 被提升的变量需要分配虚拟寄存器
- 增加了寄存器分配的复杂度
- 如果变量的 Spill 或寄存器分配不合理，可能激发出联动问题
- 需要平衡 SSA 形式的优势和寄存器压力

## 11.2 Phi 指令消除

Phi 消除虽然看起来简单，但实际实现时也有不少细节需要处理。

### 临界边分裂

**什么是临界边**

- 源块有多个后继
- 目标块有多个前驱

**为什么需要分裂**

- 直接在源块末尾插入复制会影响其他后继块
- 在目标块开头插入复制会破坏来自其他前驱的语义
- 需要创建新的中间块作为复制指令的插入位置

**分裂操作的复杂性**

- 需要修改控制流图结构
- 更新前驱和后继关系
- 维护支配树等辅助数据结构的一致性

### 并行复制解决

当多个复制操作存在依赖关系时（如 `a ← b, b ← c, c ← a`），需要：

- 引入临时变量打破循环依赖
- 或使用拓扑排序确定执行顺序
- 确保复制操作的正确性

## 11.3 LICM Pass 的实现（已实现未集成）

LICM Pass 已经实现，但尚未集成到优化管线中。实现过程中遇到的困难包括：

**循环识别**

- 如何准确识别自然循环：通过回边识别
- 构建循环结构信息：循环头、循环体块集合、循环深度
- 处理嵌套循环的情况

**前驱块构造**

- 为每个循环构造唯一的进入点（前驱块）
- 处理循环已有的外部前驱块
- 创建新的前驱块并正确更新控制流

**不变性判断**

- 判断指令是否为循环不变：所有操作数都是循环不变量
- 递归判断操作数的定义点
- 处理循环内定义但不变的变量

**Phi 节点处理**

- 外提指令后需要更新循环头的 Phi 节点
- 确保外提不会破坏 Phi 节点的语义

**与 Mem2Reg 的配合**

- SSA 形式下的不变性判断更加复杂
- 需要考虑 Phi 节点带来的数据流汇聚

## 11.4 调试经验

在实现这些优化 Pass 时，积累了一些调试经验：

**逐步验证**

- 每个Pass完成后立即打印中间IR，验证正确性
- 使用简单的测试用例验证基本功能
- 逐步增加测试用例的复杂度

**可视化辅助**

- 打印控制流图（CFG）结构
- 打印支配树信息
- 打印Phi节点的位置和参数

**边界情况**

- 测试空函数、单基本块函数
- 测试包含多层嵌套循环的函数
- 测试包含复杂条件分支的函数
- 测试不可达块的情况

**Pass间协调**

- 确保Pass的执行顺序合理
- 每个Pass不应破坏其他Pass的成果
- 使用 changed 标志触发迭代优化
