# LCC 编译器优化系统设计

## 1. 优化系统架构

### 1.1 总体架构

LCC 的优化系统采用经典的 SSA-based 优化架构，整个优化管线分为三个核心阶段：

- **SSA 构建阶段**：将传统中间表示转换为静态单赋值形式
- **优化执行阶段**：在 SSA 形式上执行多种优化变换
- **SSA 销毁阶段**：将优化后的 SSA 代码转换为可执行的目标代码

### 1.2 优化管线流程

优化管线按照以下顺序执行各优化 Pass：

1. 支配树构建
2. 内存到寄存器转换
3. 迭代优化循环
4. Phi 指令消除

## 2. 支配分析

### 2.1 支配关系定义

支配分析是构建 SSA 形式和实现多种优化的基础。给定控制流图 CFG 中的基本块 B1 和 B2，称 B1 支配 B2 当且仅当从入口块到 B2 的每条路径都必须经过 B1。每个基本块存在唯一的直接支配前驱，所有支配关系构成一棵支配树。

### 2.2 支配树算法

LCC 采用迭代算法计算支配集。算法基于数据流方程：

- 对于入口块：$Dom(entry) = {entry}$
- 对于非入口块 $b：Dom(b) = {b} ∩_{p∈pred(b)} Dom(p)$

算法通过不断迭代更新支配集直至达到不动点。对于不可达块（无前驱的块），清空其支配集以避免错误分析结果。

## 3. 优化 Pass：支配树构建

### 3.1 实现概述

支配树构建是整个优化管线的第一步，为后续的 SSA 转换和循环分析奠定基础。该 Pass 分析控制流图，计算每个基本块的支配集合，并构建支配树数据结构。

### 3.2 算法细节

支配树构建 Pass 采用迭代数据流分析方法，主要处理以下任务：

- 初始化入口块的支配集，使其仅包含自身
- 为所有非入口块初始化为包含所有基本块的支配集
- 迭代计算每个块的支配集，直至达到不动点
- 处理不可达块的特殊情况

对于不可达块（无任何前驱的块），算法将其支配集清空。这种处理确保后续分析不会错误地假设这些块被支配。

### 3.3 支配信息的应用

构建的支配树信息被以下优化 Pass 使用：

- Mem2Reg：用于支配边界计算和变量重命名遍历
- LICM：用于循环识别和不变代码判断
- 其他需要控制流分析的优化

支配树数据结构提供了快速查询支配关系的接口，包括直接支配前驱查询、支配子树遍历等。

## 4. 优化 Pass：内存到寄存器转换

### 4.1 实现概述

内存到寄存器转换是构建 SSA 形式的核心 Pass。该 Pass 将函数内栈分配的标量变量提升为虚拟寄存器，通过插入 Phi 节点并重命名变量定义，将传统中间表示转换为静态单赋值形式。

### 4.2 可提升变量识别

Pass 首先扫描函数内的所有 ALLOCA 指令，识别可提升的变量。识别标准包括：

- 变量类型为标量类型（非数组）
- 变量的所有定义和使用位置可被准确追踪

对于不可提升的变量（如数组类型变量），保留其原始的内存访问形式。同时，Pass 收集每个被提升变量的所有定义位置所在的块。

### 4.3 支配边界计算

支配边界决定 Phi 节点的插入位置。对于基本块 b，其支配边界 DF(b) 包含所有满足以下条件的块 n：

- b 支配 n 的某个前驱 p
- b 不严格支配 n

支配边界计算采用迭代算法，利用已构建的支配树加速计算过程。支配边界信息确保在控制流汇合点处插入必要的 Phi 节点。

### 4.4 Phi 节点插入

对每个需要提升的变量，Pass 执行以下操作：

- 计算所有定义位置所在块的支配边界的并集
- 在支配边界中的每个块插入 Phi 节点
- Phi 节点的结果操作数为新分配的临时寄存器

Phi 节点的参数个数等于所在块的前驱数量，每个参数对应一个前驱路径上的变量值。Phi 节点的作用是在控制流汇合点处合并来自不同路径的变量值。

### 4.5 变量重命名

变量重命名按照支配树的深度优先遍历顺序进行，主要步骤包括：

- 使用栈结构管理每个变量在不同支配路径下的当前版本
- 遇到变量定义时，分配新的临时寄存器并将新版本压入栈
- 遇到变量使用时，将使用替换为栈顶的当前版本
- 递归处理支配的子块
- 完成子块处理后，弹出栈以恢复上一层的版本

重命名过程确保每个变量定义获得唯一的临时寄存器标识，而每个使用点引用正确的变量版本。

### 4.6 内存操作替换

在重命名完成后，Pass 执行以下清理工作：

- 删除所有已提升变量的 ALLOCA 指令
- 删除对这些变量的 LOAD 和 STORE 指令
- 将 Phi 节点的操作数统一转换为临时寄存器形式

对于未提升的变量，保留其原始的内存访问指令。最终，函数内的中间表示完全转换为 SSA 形式，每个变量在其作用域内仅被赋值一次。

### 4.7 优化效果

Mem2Reg Pass 的效果包括：

- 消除大量内存访问指令，减少 load/store 开销
- 简化数据流分析，使定义-使用关系更加明确
- 为后续优化提供更好的分析基础

**应用场景**

包含多个局部变量赋值和简单计算的函数。

**示例**

```c
int compute(int x) {
    int a = x + 1;
    int b = a * 2;
    return b;
}
```

经过 Mem2Reg 后，局部变量 `a` 和 `b` 被提升到虚拟寄存器，消除了 ALLOCA/LOAD/STORE 指令。

## 5. 优化 Pass：全局常量求值

### 5.1 实现概述

全局常量求值 Pass 实现了跨函数的常量折叠功能。该 Pass 识别函数调用中所有参数为常量的情况，在编译期解释执行目标函数，将调用结果替换为常量，从而减少运行时开销。

### 5.2 常量调用模式识别

Pass 扫描函数内的指令流，识别以下模式：

- 连续的 ARG 指令序列，每个 ARG 指令的操作数为常量
- 紧随其后的 CALL 指令，调用的函数可被求值

### 5.3 解释执行机制

当识别到满足条件的常量调用时，Pass 启动内部解释器执行目标函数。解释器的主要机制包括：

- 维护变量标识符到常量值的映射表
- 模拟指令执行，逐步更新变量值
- 处理控制流，包括跳转和条件分支
- 记录最终的返回值

解释器仅支持部分指令类型，如赋值、算术运算、逻辑运算等。对于无法处理的指令（如io函数 `getint` `printf` 等），解释器终止并返回失败状态。

### 5.4 结果缓存策略

为了避免重复求值，Pass 实现了缓存机制：

- 缓存键由函数名和参数列表组成
- 缓存值为该调用组合的求值结果
- 遇到相同的调用时直接返回缓存结果

缓存机制显著提升了效率，特别是在同一个函数被多次常量调用的情况下,比如`fib` 斐波那契数列

### 5.5 递归深度控制

为了防止无限递归导致的编译器崩溃，Pass 设置了递归深度上限：

- 每次递归调用时递增深度计数器
- 当深度超过阈值时，放弃当前函数的求值
- 阈值的选取平衡了优化效果和编译时间

### 5.6 代码替换

当解释器成功求值并返回常量结果时，Pass 执行以下替换：

- 将 CALL 指令转换为 ASSIGN 指令
- ASSIGN 指令的操作数为求得的常量值
- 将相关的 ARG 指令标记为 NOP
- 置位 changed 标志以触发后续迭代优化

若求值失败（如无法处理的指令或递归深度超限），则保持原 CALL 指令不变。

### 5.7 优化效果

全局常量求值 Pass 的效果主要体现在：

- 将运行时函数调用转换为编译期常量,如`fib`
- 消除了函数调用的调用开销和参数传递开销
- 为后续常量传播 Pass 提供更多常量信息

**应用场景**

调用纯函数且参数为常量的情况。

**示例**

```c
int fib(int i) {
    if (i == 1) {
        return 1;
    }
    if (i == 2) {
        return 2;
    }
    return fib(i - 1) + fib(i - 2);
}

int main() {
  printf("%d\n", fib(10));
  return 0;
}
```

经过全局常量求值后：

```c
int main() {
  printf("%d\n", 89);
  return 0;
}
```

## 6. 优化 Pass：局部死代码消除

### 6.1 实现概述

局部死代码消除 Pass 删除对程序输出没有影响的指令。该 Pass 在基本块范围内进行，利用 SSA 形式的特性使得死代码分析更加高效和准确。

### 6.2 副作用指令定义

某些指令即使结果未被使用也不能删除，因为它们产生副作用。Pass 定义了具有副作用的指令类型：

- STORE：修改内存状态
- GOTO、IF、LABEL：影响控制流
- CALL：可能产生外部可见效果
- RETURN：影响函数返回值
- PARAM：影响函数参数传递
- ALLOCA、ARG：影响内存布局
- PHI：SSA 特有的汇聚节点

以上指令无论其结果是否被使用都不会被删除。

### 6.3 引用计数分析

Pass 采用引用计数方法识别死代码，主要步骤包括：

- 第一遍遍历：统计每个临时寄存器的使用次数
  - 扫描所有指令的操作数（arg1、arg2）
  - 统计 Phi 节点的所有参数
  - 对于 RETURN、STORE、ALLOCA、PARAM 指令，统计其结果操作数

- 第二遍遍历：删除满足条件的指令
  - 检查指令是否无副作用
  - 检查结果是否为临时寄存器
  - 检查该临时寄存器的使用计数是否为零
  - 同时满足上述条件时删除指令

### 6.4 死代码识别条件

指令被视为死代码当且仅当满足所有以下条件：

- 指令的操作码不属于副作用指令集合
- 指令的结果操作数类型为临时寄存器
- 该临时寄存器的使用计数为零

使用计数为零意味着该指令的结果没有被任何后续指令引用，因此可以安全删除。

### 6.5 迭代删除策略

Pass 在单次遍历中删除所有识别出的死代码。删除操作采用迭代器模式，确保删除后继续正确遍历剩余指令。每次删除都会置位 changed 标志，触发优化管线的后续迭代。

### 6.6 优化效果

局部 DCE Pass 的效果包括：

- 删除优化过程中产生的临时变量
- 清理常量传播、LICM 等优化留下的冗余指令
- 减少指令总数，降低代码大小
- 减轻后续 Pass 的工作负担

该 Pass 通常与其他优化 Pass 配合使用，形成优化循环，逐步清除所有死代码。

**应用场景**

优化过程中产生的中间临时变量未被使用的情况。

**示例**

```c
int compute(int x, int y) {
    int temp = x + y;
    int result = x * 2;
    return result;
}
```

经过死代码消除后：

```c
int compute(int x, int y) {
    int result = x * 2;
    return result;
}
```

**优化效果**：删除了未使用的计算 `temp = x + y`，减少了 1 条加法指令。该优化常与常量传播、代数简化等 Pass 配合，逐步清除冗余代码。

## 7. 优化 Pass：常量传播与折叠

### 7.1 实现概述

常量传播 Pass 将已知的常量值沿数据流传播到使用点，常量折叠 Pass 则用计算结果替换常量表达式。这两个优化紧密配合，能够简化表达式并暴露更多优化机会。

### 7.2 数据流分析框架

Pass 采用向前数据流分析方法在基本块内进行优化：

- 维护一个从临时寄存器到常量值的映射表
- 映射表记录当前基本块内已知的常量赋值关系
- 按指令顺序传播常量值
- 根据指令类型更新映射表

该分析仅限于基本块内部，不进行跨块的常量传播，从而简化了实现并降低了分析复杂度。

### 7.3 常量替换策略

Pass 在遍历指令时执行以下替换操作：

- 对于每个指令的操作数，检查其是否为临时寄存器
- 若是临时寄存器且在映射表中存在对应的常量值，则用常量值替换操作数
- 替换操作直接修改指令的操作数字段，不生成新指令

这种原地替换策略避免了额外的指令生成开销，同时保持了中间表示的简洁性。

### 7.4 常量折叠计算

对于二元运算指令，Pass 执行常量折叠：

- 检查两个操作数是否均为常量
- 若是，则直接计算表达式的值
- 将指令的操作码改为 ASSIGN
- 将第一个操作数改为计算结果的常量值
- 清除第二个操作数

常量折叠适用于算术运算、逻辑运算、关系运算等各类二元操作。折叠后的 ASSIGN 指令会更新映射表，供后续指令使用。

### 7.5 映射表更新规则

映射表的更新遵循以下规则：

- 对于 ASSIGN 指令，若源操作数为常量，将结果临时寄存器及其常量值存入映射表
- 对于常量折叠后的指令，同样将结果存入映射表
- 当遇到无法处理的指令（如 STORE、CALL）时，不更新映射表
- 映射表内的值可能在后续被新值覆盖

映射表的更新确保常量信息能够沿数据流正确传播。

### 7.6 与其他优化的协同

常量传播与多个优化 Pass 存在协同效应：

- 与全局常量求值协同：全局求值产生的常量可被进一步传播
- 与 DCE 协同：常量折叠可能使某些临时变量使用计数降为零
- 与 LICM 协同：常量传播有助于识别循环不变代码
- 迭代优化使这些协同效应被充分利用

### 7.7 优化效果

常量传播与折叠 Pass 的效果包括：

- 简化算术和逻辑表达式
- 减少指令总数（通过常量折叠）
- 为死代码消除创造机会
- 为循环不变代码外提提供更多候选指令

**应用场景**

包含常量赋值和常量表达式的代码。

**示例**

```c
int compute(int x) {
    int a = 5;
    int b = 10;
    int c = a + b;     // 可折叠为 15
    int d = c * 2;     // 可折叠为 30
    return d + x;
}
```

经过常量传播与折叠后：

```c
int compute(int x) {
    return 30 + x;
}
```

## 7.9 优化 Pass：代数简化

### 7.9.1 实现概述

代数简化 Pass 利用代数恒等式简化表达式，无需计算即可替换为更简单的形式。该 Pass 能够减少不必要的运算，提升代码效率。

### 7.9.2 优化模式

Pass 识别并简化以下代数模式：

- 加法：`x + 0` → `x`，`0 + x` → `x`
- 减法：`x - 0` → `x`
- 乘法：`x * 0` → `0`，`x * 1` → `x`，`1 * x` → `x`
- 除法：`x / 1` → `x`
- 取模：`x % 1` → `0`

这些简化基于数学上的恒等式，保证语义等价性。

### 7.9.3 优化效果

**应用场景**

包含常量操作的算术表达式。

**示例**

```c
int compute(int x) {
    int a = x + 0;
    int b = a * 1;
    int c = x - 0;
    int d = c * 0;
    return d;
}
```

经过代数简化后：

```c
int compute(int x) {
    int a = x;
    int b = a;
    int c = x;
    int d = 0;
    return d;
}
```

## 7.10 优化 Pass：复制传播

### 7.10.1 实现概述

复制传播 Pass 消除不必要的复制操作。当临时变量被赋值为另一个变量或临时值时，后续使用该临时变量的地方可以直接使用源操作数，从而减少复制指令。

### 7.12.1.1 代码路径与判定

实现位于 `src/optimize/LoopUnroll.cpp`，当前只处理**单基本块自循环**，判定流程：

- 块末尾必须是 `IF cond, -, label` 且 label 指向自身；`loop.blocks` 仅包含头块。
- 头块里恰好一个 `PHI`，参数 2 个，且其中一个前驱是回边（来自头块）；取 `PHI` 结果为归纳变量 `iv`，非回边参数为常量初值 `init`，回边参数对应一次递增结果。
- 在块内找到定义回边参数的 `ADD`：`iv + const_step -> next`（或交换顺序），`step` 必须是常量，且当前实现只接受正步长。
- 找到生成分支条件的比较指令，支持 `iv < limit` 或 `iv <= limit`，`limit` 必须是常量；若 `iv` 在右侧则交换并镜像比较方向。
- 计算静态迭代次数 `tripCount`，若大于 128 或初始即不成立则放弃展开或直接置 0。

### 7.12.1.2 展开行为

- 仅做**完全展开**：按 `tripCount` 次复制块内除 `PHI/IF/LABEL/GOTO` 之外的指令。
- 复制时：`iv` 被替换为当前迭代的常量；临时寄存器通过映射新分配，避免与原值冲突。
- 展开完后，头块结尾插入 `GOTO exit`，`exit` 取自头块的第一个不在循环内的后继（fallthrough 优先）。不保留余数循环，也不保留原条件检查。

### 7.12.1.3 现有限制与风险

- 不支持多块循环、负步长、`>=`/`>` 比较，也不处理循环体中的副作用过滤。
- 当 `tripCount == 0` 时会直接删除循环体并跳转出口，需确保静态判定正确。
- 只尝试一个循环后即返回，批量展开需多轮调用。

### 7.10.2 复制链追踪

Pass 维护复制映射表，记录临时变量之间的复制关系。对于复制链 `t1 = t0, t2 = t1, t3 = t2`，Pass 会递归追踪到原始源，将 `t3` 的所有使用替换为 `t0`。

### 7.10.3 优化效果

**应用场景**

包含临时变量复制的代码。

**示例**

```c
int compute(int x, int y) {
    int t1 = x;
    int t2 = t1;
    int t3 = t2;
    return t3 + y;
}
```

经过复制传播后：

```c
// 优化后
int compute(int x, int y) {
    return x + y;
}
```

## 7.11 优化 Pass：公共子表达式消除

### 7.11.1 实现概述

公共子表达式消除（CSE）Pass 删除重复计算相同表达式的指令。当相同的表达式被多次计算且操作数未改变时，后续计算可以复用首次计算的结果。

### 7.11.2 表达式识别

Pass 基于支配树分析，在支配范围内追踪已计算的表达式。对于表达式 `e = op(arg1, arg2)`，Pass 使用哈希表记录 `op(arg1, arg2)` 到结果临时寄存器的映射。遇到相同表达式时，直接复用已有结果。

### 7.11.3 交换律处理

对于满足交换律的操作（如 `+`、`*`、`==`、`&&`），Pass 在哈希时规范化操作数顺序，确保 `a + b` 和 `b + a` 被识别为相同表达式。

### 7.11.4 优化效果

**应用场景**

重复计算相同表达式的代码。

**示例**

```c
int compute(int a, int b, int c) {
    int x = a + b;
    int y = a + b;
    int z = x + y;
    return z;
}
```

经过 CSE 后：

```c
int compute(int a, int b, int c) {
    int x = a + b;
    int y = x;        // 复用 x 的结果
    int z = x + y;
    return z;
}
```

## 7.12 优化 Pass：循环展开（Loop Unroll）

### 7.12.1 实现概述

循环展开通过复制循环体指令减少分支开销、提升指令级并行，并暴露常量折叠与 CSE 机会。当前实现是静态、阈值驱动的展开，无运行时回退。

### 7.12.2 展开策略

- **完全展开**：trip count 在编译期，则复制循环体 `trip_count` 次并移除循环控制。
- **部分展开（k 因子）**：trip count 不可知时选择固定因子 `k`，生成：
  - 展开体：复制循环体 `k` 次，归纳变量在每份体内递增步长倍数。
  - 余数循环：保留原循环头处理 `trip_count % k` 尾迭代。

### 7.12.3 关键变换

- **归纳变量重写**：展开体内对归纳变量显式累加 `k * step`；尾循环保持原比较。
- **标签与跳转重映射**：复制体时重新分配标签/临时，维护后继与回边连接正确。
- **PHI 处理**：复制体内 PHI 重写前驱；循环入口/出口 PHI 由后续 PhiElim 统一处理。

## 8. 优化 Pass：循环不变代码外提

### 8.1 实现概述

循环不变代码外提 Pass 将循环体中不随迭代改变的指令移到循环前，避免每次迭代时重复执行相同的计算。该 Pass 能够显著减少循环内的计算量，提升程序性能。

### 8.2 循环识别机制

Pass 首先需要识别程序中的循环结构。基于支配树信息，Pass 识别自然循环：

- 检测控制流图中的回边（即从后继块跳转回其支配前驱的边）
- 回边的目标块即为循环头
- 从循环头出发，通过反向遍历回边，收集所有可达的块
- 这些块构成循环体

循环识别模块提供循环结构信息，包括循环头、循环体块集合、循环深度等。

### 8.3 前驱块构造策略

为了能够安全地外提代码，需要为每个循环构造一个唯一的前驱块。前驱块的作用是作为所有从循环外部进入循环的控制流必经路径。

前驱块构造算法处理以下情况：

- 如果循环已存在唯一的外部前驱块，且该块仅跳转到循环头，则直接复用该块作为前驱块

- 否则，创建一个新的前驱块：
  - 为新前驱块分配标签并初始化指令
  - 将所有来自循环外部的前驱块的跳转目标修改为新前驱块
  - 新前驱块无条件跳转到循环头
  - 更新循环头的 Phi 节点，将来自外部前驱的入边参数修改为指向前驱块

前驱块构造确保了循环有唯一的进入点，为代码外提提供了安全的插入位置。

### 8.4 循环不变性判断

Pass 需要判断循环体内的每条指令是否为循环不变代码。判断条件包括：

- 指令的所有操作数均为循环不变量：
  - 常量被视为循环不变
  - 在循环外定义的临时寄存器被视为循环不变
- 指令不依赖于循环体内的定义：即所有操作数的定义点都在循环外
- 指令不会抛出异常或产生副作用：如 STORE、CALL 等指令不能外提
- 指令的执行结果在所有迭代中都相同

满足上述条件的指令被视为循环不变代码，可以安全地外提到循环前。

### 8.5 代码外提操作

对于识别出的循环不变代码，Pass 执行以下外提操作：

- 将指令从循环体中删除
- 将指令插入到前驱块的末尾（在跳转到循环头的指令之前）
- 保持指令的操作数和结果不变

外提操作遵循控制流不变原则，确保外提后的程序语义与原程序相同。

### 8.6 控制流更新

代码外提后，Pass 更新相关的控制流信息：

- 更新前驱块的指令序列
- 保持前驱块到循环头的跳转关系
- 确保循环头的 Phi 节点仍然正确引用前驱块

Pass 还需要处理特殊情况，如循环嵌套、外提指令与循环体内其他指令的依赖关系等。

### 8.7 优化效果

LICM Pass 的效果主要体现在：

- 减少循环体内的指令数量
- 避免重复计算相同的表达式
- 对于包含数组边界检查、不变函数调用等操作的循环，性能提升尤为明显
- 与常量传播、DCE 等优化协同，进一步暴露优化机会

**应用场景**

循环体内有不随迭代变化的计算。

**示例**

```c
int sum_array(int arr[], int n) {
    int len = get_length(arr);
    int sum = 0;
    for (int i = 0; i < n; i++) {
        int bound = len * 2;
        if (arr[i] < bound) {
            sum += arr[i];
        }
    }
    return sum;
}
```

经过循环不变代码外提后：

```c
int sum_array(int arr[], int n) {
    int len = get_length(arr);
    int sum = 0;
    int bound = len * 2;
    for (int i = 0; i < n; i++) {
        if (arr[i] < bound) {
            sum += arr[i];
        }
    }
    return sum;
}
```

## 9. 优化 Pass：Phi 指令消除

### 9.1 实现概述

Phi 指令消除是 SSA 销毁阶段的唯一 Pass。该 Pass 将 SSA 形式中特有的 Phi 指令转换为普通的复制指令，使中间表示能够被后端代码生成器直接使用。Phi 消除是优化管线中的最后一步，完成后即可进行目标代码生成。

### 9.2 Phi 指令的语义

Phi 指令表示在控制流汇合点处根据来源基本块选择相应的变量值。对于形式为 `result = φ(v1, v2, ..., vn)` 的 Phi 节点，其语义是：

- 若控制流从第 i 个前驱块进入当前块，则 result 的值为 vi
- Phi 节点的参数数量等于所在块的前驱数量
- 每个 Phi 参数对应一个前驱路径上的变量值

Phi 指令是一种编译器内部表示，目标代码中不存在对应的直接实现。

### 9.3 临界边问题

Phi 消除面临的主要挑战是如何处理临界边。临界边定义为：

- 源块有多个后继
- 目标块有多个前驱

对于临界边，直接在源块末尾插入复制指令会影响其他后继块，在目标块开头插入复制指令会破坏来自其他前驱的语义。因此需要特殊处理。

### 9.4 复制需求收集

Pass 首先收集所有 Phi 节点对应的复制需求：

- 遍历每个基本块的所有 Phi 节点
- 对于每个 Phi 节点的每个入边（前驱块 p 到当前块 b）：
  - 记录复制目标：Phi 节点的结果操作数
  - 记录复制源：Phi 节点对应的参数操作数
  - 将该复制需求关联到边 (p, b)

所有复制需求按边组织，形成从边到复制列表的映射。每个复制列表包含该边对应的所有 Phi 复制需求。

### 9.5 临界边分裂算法

对于每条边，Pass 检查其是否为临界边。若是，则执行以下分裂操作：

- 创建一个新的基本块（分裂块）作为源块和目标块之间的中介
- 为分裂块分配标签并初始化指令序列
- 将源块的所有指向目标块的跳转指令修改为指向分裂块
- 在分裂块末尾添加无条件跳转指令，跳转到目标块
- 将属于该边的所有复制操作插入到分裂块中

临界边分裂确保了每条边都有唯一的插入位置，同时不破坏其他边的语义。

### 9.6 非临界边处理

对于非临界边，Pass 根据边的性质选择复制操作的插入位置：

- 若目标块仅有这一个前驱：将所有复制操作插入到目标块开头（在 Phi 节点之前）
- 若源块仅有这一个后继：将所有复制操作插入到源块末尾（在跳转指令之前）

这种策略最大限度地减少了对控制流图的修改，同时确保了复制的正确执行。

### 9.7 并行复制解决

对于插入到同一位置的多个复制操作，可能存在依赖关系。例如，复制序列 `a ← b, b ← c, c ← a` 存在循环依赖。Pass 采取以下策略解决并行复制问题：

- 对于没有依赖关系的复制，顺序执行即可
- 对于存在依赖关系的复制，通过引入临时变量打破依赖循环
- 具体实现可采用拓扑排序或临时变量引入等方法

并行复制解决确保了复制操作的正确执行，不会因为依赖关系导致错误的值覆盖。

### 9.8 Phi 节点清除

所有 Phi 节点处理完成后，Pass 执行清理工作：

- 将所有 Phi 节点的操作码改为 NOP
- 清除 Phi 节点的所有操作数
- NOP 指令会被后续的死代码消除 Pass 清理

### 9.9 控制流图更新

Phi 消除过程会修改控制流图结构（插入新的分裂块），因此需要更新基本块之间的前驱和后继关系：

- 更新源块的后继列表，将目标块替换为分裂块
- 更新目标块的前驱列表，将源块替换为分裂块
- 建立分裂块的前驱和后继关系
- 更新支配树等辅助数据结构

### 9.10 优化效果

Phi 消除是 SSA 销毁的关键步骤，其效果包括：

- 将 SSA 特有的 Phi 指令转换为可执行的复制指令
- 通过临界边分裂确保转换的正确性
- 为后续代码生成提供简洁的中间表示

**应用场景**

包含条件分支和循环的函数，使用 SSA 形式后需要转换回可执行代码。

**示例**

```c
if (condition) {
    x_1 = 10;
} else {
    x_2 = 20;
}
x_3 = φ(x_1, x_2);
return x_3;
```

经过 Phi 消除后（转换为复制指令）：

```c
if (condition) {
    x = 10;
    goto merge;
} else {
    x = 20;
    goto merge;
}
merge:
return x;
```

## 10. 优化管线协调

### 10.1 Pass 间的协同效应

各优化 Pass 之间存在密切的协同关系：

- 常量传播将临时变量替换为常量，可能为 DCE 提供更多优化机会
- DCE 删除冗余指令，可能暴露新的常量传播机会
- LICM 外提的代码可能包含新的常量传播机会
- 全局常量求值生成的常量可以被常量传播进一步传播

迭代策略确保这些协同效应被充分利用。每一轮迭代都会基于上一轮的结果进行优化，逐步逼近局部最优解。

## 11. 其他小优化

### 11.1 常量折叠

- 在`codegen`阶段直接尝试对简单的常量表达式进行折叠，减少运行时计算

### 11.2 强度消减

- 对于乘法，如果遇到有$2^n$的操作数，则转换为左移操作
  $$ 2^n * x | x * 2^n with shift optimization $$
- 对于除法，我们采用了魔法数的方法将除法转换为乘法+移位的形式
  $$x / 2^k => (x + (x < 0 ? (2^k - 1) : 0)) >> k$$
- 对于取模，我们把他转化为乘除法，其中除法采用魔法数来进行强度消减
  $$ x \% y => x - (x / y) * y $$

### 11.3 叶子函数优化

- 对于叶子函数，我们可以不去保存 `$ra`，因为没有函数会调用叶子函数

# 12. 做优化时遇到的困难

## 12.1 Mem2Reg

- **能不能提升**：数组一律不能升，标量也要把所有 def/use 梳理干净。
- **支配边界计算**：这是和其他的Pass比如CFG,Dom计算有联动的，这几个出现了问题不好排查。
- **Phi 位置和参数**：前驱顺序、前驱块更新、参数数量必须匹配，少一个前驱就会在后端拿到奇怪的并行复制。
- **use/def 分类**：STORE 的 base/index 都是 use，result 不是；Phi 的所有参数都是 use。早期把 STORE 的 result 当 def，活跃性分析全乱，这点和糟糕的 ir 设计也有关系
- **和后端的压力传递**：变量全提上寄存器后，寄存器分配很容易溢出。因此会暴露出后端寄存器分配算法的问题

可以发现 `Mem2Reg` 和许多其他的编译器组件产生联系，出现了问题相当不好排查，因此这是最困难的一步，走出这一步，编译器优化将直接起飞，并且由于是自制四元中间式，
早期的设计无法满足要求，进行了多次重构（原来的ir一个指令做了太多事了），也许用llvm ir会好很多？

## 12.2 Phi 消除

- **临界边分裂**：源多后继 + 目标多前驱就必须分裂，否则复制会污染其他路径。
- **并行复制顺序**：`a←b, b←c, c←a` 这种环必须引入临时变量才能拆开。

## 12.3 副作用

在做编译器优化尤其要注意副作用，比如和运行时内存有关的部分要特别注意,如果没有搞清楚自定义的ir的副作用,
那么优化实际上是难以进行的。
